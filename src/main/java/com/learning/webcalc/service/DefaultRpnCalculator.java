package com.learning.webcalc.service;import com.learning.webcalc.service.api.CalculationException;import com.learning.webcalc.service.api.IntegralCalculator;import com.learning.webcalc.service.api.RpnCalculator;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.util.List;import java.util.Stack;import static com.learning.webcalc.service.util.Constants.INTEGRAL_SYMBOL;import static com.learning.webcalc.service.util.Constants.SQRT_SYMBOL;import static com.learning.webcalc.service.util.ExpressionUtil.isFunction;@Componentpublic class DefaultRpnCalculator implements RpnCalculator{    private IntegralCalculator integralCalculator;    @Autowired    public DefaultRpnCalculator(IntegralCalculator integralCalculator)    {        this.integralCalculator = integralCalculator;    }    @Override    public Double calculate(List<Object> tokens)    {        if (tokens.isEmpty())        {            return 0d;        }        Stack<Object> stack = new Stack<>();        for (Object token : tokens)        {            if (token instanceof Number)            {                stack.push(token);                continue;            }            else if (token instanceof Operator)            {                double argument2 = (Double)stack.pop();                double argument1 = (Double)stack.pop();                double result = ((Operator)token).apply(argument1, argument2);                stack.push(result);            }            else if (isFunction(token))            {                stack.push(executeFunction(token, stack));            }            else            {                throw CalculationException.forUnexpectedToken(token);            }        }        double result = (Double)stack.pop();        if (!stack.isEmpty())        {            throw CalculationException.forUnexpectedToken(stack.peek());        }        return result;    }    private double executeFunction(Object token, Stack<Object> stack)    {        if (token.equals(SQRT_SYMBOL))        {            return executeSqrt(stack);        }        if (token.equals(INTEGRAL_SYMBOL))        {            return executeIntegral(stack);        }        throw CalculationException.forUnexpectedToken(token);    }    private double executeSqrt(Stack<Object> stack)    {        double value = (Double)stack.pop();        if (value < 0)        {            throw CalculationException.forNegativeSqrt(value);        }        return Math.sqrt(value);    }    private double executeIntegral(Stack<Object> stack)    {        int threadCount = (int)Math.round((Double)stack.pop());        int intervalCount = (int)Math.round((Double)stack.pop());        double upperBound = (Double)stack.pop();        double lowerBound = (Double)stack.pop();        try        {            return integralCalculator.calculate(lowerBound, upperBound, intervalCount, threadCount);        }        catch (InterruptedException e)        {            throw CalculationException.forProcessingError(e);        }    }}
package com.learning.webcalc.service;import com.learning.webcalc.service.api.CalculationException;import com.learning.webcalc.service.api.IntegralCalculator;import com.learning.webcalc.service.api.RpnCalculator;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.util.List;import java.util.Stack;import static com.learning.webcalc.service.util.ExpressionUtil.isFunction;import static com.learning.webcalc.service.util.ExpressionUtil.isOperator;@Componentpublic class DefaultRpnCalculator implements RpnCalculator{    private IntegralCalculator integralCalculator;    @Autowired    public DefaultRpnCalculator(IntegralCalculator integralCalculator)    {        this.integralCalculator = integralCalculator;    }    @Override    public Double calculate(List<Object> tokens)    {        if (tokens.isEmpty())        {            return 0d;        }        Stack<Object> stack = new Stack<>();        for (Object token : tokens)        {            if (token instanceof Number)            {                stack.push(token);                continue;            }            else if (isOperator(token))            {                double result = calculate(token, (Double)stack.pop(), (Double)stack.pop());                stack.push(result);            }            else if (isFunction(token))            {                stack.push(executeFunction(token, stack));            }            else            {                throw CalculationException.forUnexpectedToken(token);            }        }        double result = (Double)stack.pop();        if (!stack.isEmpty())        {            throw CalculationException.forUnexpectedToken(stack.peek());        }        return result;    }    private double calculate(Object operator, double value2, double value1)    {        if (operator.equals("+"))        {            return value1 + value2;        }        if (operator.equals("-"))        {            return value1 - value2;        }        if (operator.equals("*"))        {            return value1 * value2;        }        if (operator.equals("/"))        {            if (value2 == 0)            {                throw CalculationException.forDivisionByZero();            }            return value1 / value2;        }        if (operator.equals("^"))        {            return Math.pow(value1, value2);        }        throw CalculationException.forUnexpectedToken(operator);    }    private double executeFunction(Object token, Stack<Object> stack)    {        if (token.equals("s"))        {            return Math.sqrt((Double)stack.pop());        }        if (token.equals("i"))        {            return executeIntegral(stack);        }        throw CalculationException.forUnexpectedToken(token);    }    private double executeIntegral(Stack<Object> stack)    {        int threadCount = (int)Math.round((Double)stack.pop());        int intervalCount = (int)Math.round((Double)stack.pop());        double upperBound = (Double)stack.pop();        double lowerBound = (Double)stack.pop();        try        {            return integralCalculator.calculate(lowerBound, upperBound, intervalCount, threadCount);        }        catch (InterruptedException e)        {            throw CalculationException.forProcessingError(e);        }    }}